(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.graphvizBuilder = {}));
})(this, (function (exports) { 'use strict';

  var graphviz = {};

  var graph$1 = {};

  var hash = {};

  var Hash$2 = function() {
    this.items = new Map();
    var i, value;
    for (i = 0, l = arguments.length; i < l; i += 2) {
      value = arguments[i + 1];
      if (value !== undefined) {
        this.items.set(arguments[i], value);
      }
    }
  };
  hash.Hash = Hash$2;
  Hash$2.prototype.removeItem = function(in_key) {
    var tmp_previous = this.items.get(in_key);
    if (tmp_previous !== undefined) {
      this.items.delete(in_key);
    }
    return tmp_previous;
  };
  Hash$2.prototype.getItem = function(in_key) {
    return this.items.get(in_key);
  };
  Hash$2.prototype.setItem = function(in_key, in_value) {
    var tmp_previous;
    if (in_value !== undefined) {
      tmp_previous = this.items.get(in_key);
      this.items.set(in_key, in_value);
    }
    return tmp_previous;
  };
  Hash$2.prototype.hasItem = function(in_key) {
    return this.items.has(in_key);
  };
  Hash$2.prototype.clear = function() {
    this.items.clear();
  };
  Object.defineProperty(Hash$2.prototype, 'length', {
    get: function() {
      return this.items.size;
    }
  });

  var node = {};

  var attributs = {};

  var Hash$1 = hash.Hash;
  var attrs = {
    Damping: { usage: 'G', type: 'double' },
    K: { usage: 'GC', type: 'double' },
    URL: { usage: 'ENGC', type: 'escString' },
    area: { usage: 'NC', type: 'double' },
    arrowhead: { usage: 'E', type: 'arrowType' },
    arrowsize: { usage: 'E', type: 'double' },
    arrowtail: { usage: 'E', type: 'arrowType' },
    aspect: { usage: 'G', type: 'aspectType' },
    bb: { usage: 'G', type: 'rect' },
    bgcolor: { usage: 'GC', type: 'color' },
    center: { usage: 'G', type: 'bool' },
    charset: { usage: 'G', type: 'string' },
    clusterrank: { usage: 'G', type: 'clusterMode' },
    color: { usage: 'ENC', type: 'color' },
    colorscheme: { usage: 'ENCG', type: 'string' },
    comment: { usage: 'ENG', type: 'string' },
    compound: { usage: 'G', type: 'bool' },
    concentrate: { usage: 'G', type: 'bool' },
    constraint: { usage: 'E', type: 'bool' },
    decorate: { usage: 'E', type: 'bool' },
    defaultdist: { usage: 'G', type: 'double' },
    dim: { usage: 'G', type: 'int' },
    dimen: { usage: 'G', type: 'int' },
    dir: { usage: 'E', type: 'dirType' },
    diredgeconstraints: { usage: 'G', type: 'string' },
    distortion: { usage: 'N', type: 'double' },
    dpi: { usage: 'G', type: 'double' },
    edgeURL: { usage: 'E', type: 'escString' },
    edgehref: { usage: 'E', type: 'escString' },
    edgetarget: { usage: 'E', type: 'escString' },
    edgetooltip: { usage: 'E', type: 'escString' },
    epsilon: { usage: 'G', type: 'double' },
    esep: { usage: 'G', type: 'double' },
    fillcolor: { usage: 'NEC', type: 'color' },
    fixedsize: { usage: 'N', type: 'bool' },
    fontcolor: { usage: 'ENGC', type: 'color' },
    fontname: { usage: 'ENGC', type: 'string' },
    fontnames: { usage: 'G', type: 'string' },
    fontpath: { usage: 'G', type: 'string' },
    fontsize: { usage: 'ENGC', type: 'double' },
    group: { usage: 'N', type: 'string' },
    headURL: { usage: 'E', type: 'escString' },
    headclip: { usage: 'E', type: 'bool' },
    headhref: { usage: 'E', type: 'escString' },
    headlabel: { usage: 'E', type: 'lblString' },
    headport: { usage: 'E', type: 'portPos' },
    headtarget: { usage: 'E', type: 'escString' },
    headtooltip: { usage: 'E', type: 'escString' },
    height: { usage: 'N', type: 'double' },
    href: { usage: 'ENGC', type: 'escString' },
    id: { usage: 'GNE', type: 'lblString' },
    image: { usage: 'N', type: 'string' },
    imagepath: { usage: 'G', type: 'string' },
    imagescale: { usage: 'N', type: 'string' },
    label: { usage: 'ENGC', type: 'lblString' },
    labelURL: { usage: 'E', type: 'escString' },
    labelangle: { usage: 'E', type: 'double' },
    labeldistance: { usage: 'E', type: 'double' },
    labelfloat: { usage: 'E', type: 'bool' },
    labelfontcolor: { usage: 'E', type: 'color' },
    labelfontname: { usage: 'E', type: 'string' },
    labelfontsize: { usage: 'E', type: 'double' },
    labelhref: { usage: 'E', type: 'escString' },
    labeljust: { usage: 'GC', type: 'string' },
    labelloc: { usage: 'NGC', type: 'string' },
    labeltarget: { usage: 'E', type: 'escString' },
    labeltooltip: { usage: 'E', type: 'escString' },
    landscape: { usage: 'G', type: 'bool' },
    layer: { usage: 'ENC', type: 'layerRange' },
    layerlistsep: { usage: 'G', type: 'string' },
    layers: { usage: 'G', type: 'layerList' },
    layerselect: { usage: 'G', type: 'layerRange' },
    layersep: { usage: 'G', type: 'string' },
    layout: { usage: 'G', type: 'string' },
    len: { usage: 'E', type: 'double' },
    levels: { usage: 'G', type: 'int' },
    levelsgap: { usage: 'G', type: 'double' },
    lhead: { usage: 'E', type: 'string' },
    lheight: { usage: 'GC', type: 'double' },
    lp: { usage: 'EGC', type: 'point' },
    ltail: { usage: 'E', type: 'string' },
    lwidth: { usage: 'GC', type: 'double' },
    margin: { usage: 'NGC', type: 'pointf' },
    maxiter: { usage: 'G', type: 'int' },
    mclimit: { usage: 'G', type: 'double' },
    mindist: { usage: 'G', type: 'double' },
    minlen: { usage: 'E', type: 'int' },
    mode: { usage: 'G', type: 'string' },
    model: { usage: 'G', type: 'string' },
    mosek: { usage: 'G', type: 'bool' },
    nodesep: { usage: 'G', type: 'double' },
    nojustify: { usage: 'GCNE', type: 'bool' },
    normalize: { usage: 'G', type: 'bool' },
    nslimit: { usage: 'G', type: 'double' },
    nslimit1: { usage: 'G', type: 'double' },
    ordering: { usage: 'GN', type: 'string' },
    orientation: { usage: 'GN', type: 'string' },
    outputorder: { usage: 'G', type: 'outputMode' },
    overlap: { usage: 'G', type: 'string' },
    overlap_scaling: { usage: 'G', type: 'double' },
    pack: { usage: 'G', type: 'int' },
    packmode: { usage: 'G', type: 'packMode' },
    pad: { usage: 'G', type: 'pointf' },
    page: { usage: 'G', type: 'pointf' },
    pagedir: { usage: 'G', type: 'pagedir' },
    pencolor: { usage: 'C', type: 'color' },
    penwidth: { usage: 'CNE', type: 'double' },
    peripheries: { usage: 'NC', type: 'int' },
    pin: { usage: 'N', type: 'bool' },
    pos: { usage: 'EN', type: 'point' },
    quadtree: { usage: 'G', type: 'quadType' },
    quantum: { usage: 'G', type: 'double' },
    rank: { usage: 'S', type: 'rankType' },
    rankdir: { usage: 'G', type: 'rankdir' },
    ranksep: { usage: 'G', type: 'double' },
    ratio: { usage: 'G', type: 'string' },
    rects: { usage: 'N', type: 'rect' },
    regular: { usage: 'N', type: 'bool' },
    remincross: { usage: 'G', type: 'bool' },
    repulsiveforce: { usage: 'G', type: 'double' },
    resolution: { usage: 'G', type: 'double' },
    root: { usage: 'GN', type: 'string' },
    rotate: { usage: 'G', type: 'int' },
    rotation: { usage: 'G', type: 'double' },
    samehead: { usage: 'E', type: 'string' },
    sametail: { usage: 'E', type: 'string' },
    samplepoints: { usage: 'N', type: 'int' },
    scale: { usage: 'G', type: 'double' },
    searchsize: { usage: 'G', type: 'int' },
    sep: { usage: 'G', type: 'double' },
    shape: { usage: 'N', type: 'shape' },
    shapefile: { usage: 'N', type: 'string' },
    showboxes: { usage: 'ENG', type: 'int' },
    sides: { usage: 'N', type: 'int' },
    size: { usage: 'G', type: 'pointf' },
    skew: { usage: 'N', type: 'double' },
    smoothing: { usage: 'G', type: 'smoothType' },
    sortv: { usage: 'GCN', type: 'int' },
    splines: { usage: 'G', type: 'string' },
    start: { usage: 'G', type: 'startType' },
    style: { usage: 'ENCG', type: 'style' },
    stylesheet: { usage: 'G', type: 'string' },
    tail_lp: { usage: 'E', type: 'pointf' },
    tailURL: { usage: 'E', type: 'escString' },
    tailclip: { usage: 'E', type: 'bool' },
    tailhref: { usage: 'E', type: 'escString' },
    taillabel: { usage: 'E', type: 'lblString' },
    tailport: { usage: 'E', type: 'portPos' },
    tailtarget: { usage: 'E', type: 'escString' },
    tailtooltip: { usage: 'E', type: 'escString' },
    target: { usage: 'ENGC', type: 'escString' },
    tooltip: { usage: 'NEC', type: 'escString' },
    truecolor: { usage: 'G', type: 'bool' },
    vertices: { usage: 'N', type: 'pointfList' },
    viewport: { usage: 'G', type: 'viewPort' },
    voro_margin: { usage: 'G', type: 'double' },
    weight: { usage: 'E', type: 'double' },
    width: { usage: 'N', type: 'double' },
    xlabel: { usage: 'EN', type: 'lblString' },
    z: { usage: 'N', type: 'double' },
  };
  var gType = {
    E: 'edge',
    N: 'node',
    G: 'graph',
    C: 'cluster',
  };
  var quotedTypes = [
    'escString',
    'rect',
    'color',
    'colorList',
    'string',
    'lblString',
    'portPos',
    'point',
    'pointf',
    'pointfList',
    'splineType',
    'style',
    'viewPort',
  ];
  function mustBeQuoted(data) {
    return quotedTypes.indexOf(attrs[data].type) !== -1;
  }
  function quoteMe(attr, value) {
    if (value[0] === '!') {
      return '<' + value.substr(1, 1000) + '>';
    }
    if (mustBeQuoted(attr)) {
      return ' "' + value + '"';
    }
    return value;
  }
  function validateAttribut(name, type) {
    if (attrs[name]) {
      return attrs[name].usage.indexOf(type) > -1;
    }
    return false;
  }
  attributs.isValid = function(name, type) {
    return validateAttribut(name, type);
  };
  var Attributs$3 = function(t) {
    this._type = t;
    this.attributs = new Hash$1();
  };
  attributs.Attributs = Attributs$3;
  Attributs$3.prototype.length = function() {
    return this.attributs.length;
  };
  Attributs$3.prototype.set = function(name, value) {
    if (validateAttribut(name, this._type) === false) {
      console.error('Warning : Invalid attribut `' + name + "' for a " + gType[this._type]);
    }
    this.attributs.setItem(name, value);
  };
  Attributs$3.prototype.get = function(name) {
    return this.attributs.getItem(name);
  };
  Attributs$3.prototype.to_dot = function() {
    var attrsOutput = '',
        sep = '',
        keys, entry, name;
    if (this.attributs.length > 0) {
      attrsOutput += ' [ ';
      for (keys = this.attributs.items.entries();;) {
        entry = keys.next();
        if (entry.done) break;
        entry = entry.value;
        name = entry[0];
        attrsOutput += sep + name + ' =' + quoteMe(name, entry[1]);
        if (!sep) sep = ', ';
      }
      attrsOutput += ' ]';
    }
    return attrsOutput;
  };

  var Attributs$2 = attributs.Attributs;
  var Node$1 = function(graph, id) {
    this.relativeGraph = graph;
    this.id = id;
    this.attributs = new Attributs$2('N');
  };
  node.Node = Node$1;
  Node$1.prototype.to = function(id, attrs) {
    this.relativeGraph.addEdge(this, id, attrs);
    return this.relativeGraph.from(id);
  };
  Node$1.prototype.set = function(name, value) {
    this.attributs.set(name, value);
    return this;
  };
  Node$1.prototype.get = function(name) {
    return this.attributs.get(name);
  };
  Node$1.prototype.to_dot = function() {
    var nodeOutput = '"' + this.id + '"' + this.attributs.to_dot();
    return nodeOutput;
  };

  var edge = {};

  var Attributs$1 = attributs.Attributs;
  var Edge$1 = function(graph, nodeOne, nodeTwo) {
    this.relativeGraph = graph;
    this.nodeOne = nodeOne;
    this.nodeTwo = nodeTwo;
    this.attributs = new Attributs$1('E');
  };
  edge.Edge = Edge$1;
  Edge$1.prototype.set = function(name, value) {
    this.attributs.set(name, value);
    return this;
  };
  Edge$1.prototype.get = function(name) {
    return this.attributs.get(name);
  };
  Edge$1.prototype.to_dot = function() {
    var edgeLink = '->';
    if (this.relativeGraph.type === 'graph') {
      edgeLink = '--';
    }
    var edgeOutput = '"' + this.nodeOne.id + '"' + ' ' + edgeLink + ' ' + '"' + this.nodeTwo.id + '"';
    edgeOutput += this.attributs.to_dot();
    return edgeOutput;
  };

  var Hash = hash.Hash,
    Node = node.Node,
    Edge = edge.Edge,
    gvattrs = attributs;
  var Attributs = gvattrs.Attributs;
  var Graph$1 = function(graph, id) {
    this.relativeGraph = graph;
    this.id = id;
    this.type = 'graph';
    this.isStrict = false;
    this.gvPath = '';
    this.nodes = new Hash();
    this.edges = [];
    this.clusters = new Hash();
    if (this.relativeGraph == null) {
      this.graphAttributs = new Attributs('G');
    } else {
      this.graphAttributs = new Attributs('C');
    }
    this.nodesAttributs = new Attributs('N');
    this.edgesAttributs = new Attributs('E');
    this.use = 'dot';
  };
  graph$1.Graph = Graph$1;
  Graph$1.prototype.addNode = function(id, attrs) {
    var node = new Node(this, id);
    var k;
    this.nodes.setItem(id, node);
    if (attrs) {
      for (k in attrs) {
        node.set(k, attrs[k]);
      }
    }
    return node;
  };
  Graph$1.prototype.removeNode = function(id, force) {
    if (force === true) {
      for (let i = 0, l = this.edges.length; i < l;) {
        const edge = this.edges[i];
        if (edge.nodeOne.id === id || edge.nodeTwo.id === id) {
          this.edges.splice(i, 1);
          --l;
        } else {
          ++i;
        }
      }
    }
    this.nodes.removeItem(id);
  };
  Graph$1.prototype.getNode = function(id) {
    return this.nodes.getItem(id);
  };
  Graph$1.prototype.from = function(id) {
    var node = this.nodes.getItem(id);
    if (node === undefined) {
      node = this.addNode(id);
    }
    return node;
  };
  Graph$1.prototype.nodeCount = function() {
    return this.nodes.length;
  };
  Graph$1.prototype.addEdge = function(nodeOne, nodeTwo, attrs) {
    var _nodeOne = nodeOne;
    var _nodeTwo = nodeTwo;
    if (typeof nodeOne === 'string') {
      _nodeOne = this.nodes.getItem(nodeOne);
      if (_nodeOne === undefined) {
        _nodeOne = this.addNode(nodeOne);
      }
    }
    if (typeof nodeTwo === 'string') {
      _nodeTwo = this.nodes.getItem(nodeTwo);
      if (_nodeTwo === undefined) {
        _nodeTwo = this.addNode(nodeTwo);
      }
    }
    var edge = new Edge(this, _nodeOne, _nodeTwo);
    var k;
    if (attrs) {
      for (k in attrs) {
        edge.set(k, attrs[k]);
      }
    }
    this.edges.push(edge);
    return edge;
  };
  Graph$1.prototype.edgeCount = function() {
    return this.edges.length;
  };
  Graph$1.prototype.addCluster = function(id) {
    var cluster = new Graph$1(this, id);
    cluster.type = this.type;
    this.clusters.setItem(id, cluster);
    return cluster;
  };
  Graph$1.prototype.getCluster = function(id) {
    return this.clusters.getItem(id);
  };
  Graph$1.prototype.clusterCount = function() {
    return this.clusters.length;
  };
  Graph$1.prototype.set = function(name, value) {
    this.graphAttributs.set(name, value);
    return this;
  };
  Graph$1.prototype.get = function(name) {
    return this.graphAttributs.get(name);
  };
  Graph$1.prototype.setNodeAttribut = function(name, value) {
    this.nodesAttributs.set(name, value);
  };
  Graph$1.prototype.getNodeAttribut = function(name) {
    return this.nodesAttributs.get(name);
  };
  Graph$1.prototype.setEdgeAttribut = function(name, value) {
    this.edgesAttributs.set(name, value);
  };
  Graph$1.prototype.getEdgeAttribut = function(name) {
    return this.edgesAttributs.get(name);
  };
  Graph$1.prototype.setOptions = function(options) {
    var attr;
    if (options.G !== undefined) {
      for (attr in options.G) {
        this.set(attr, options.G[attr]);
      }
    }
    if (options.N !== undefined) {
      for (attr in options.N) {
        this.setNodeAttribut(attr, options.N[attr]);
      }
    }
    if (options.E !== undefined) {
      for (attr in options.E) {
        this.setEdgeAttribut(attr, options.E[attr]);
      }
    }
    if (options.use !== undefined) {
      this.use = options.use;
      this.set('layout', this.use);
    }
  };
  Graph$1.prototype.to_dot = function() {
    var i, l, keys, entry;
    var dotScript = '';
    if (this.relativeGraph == null) {
      dotScript = this.type + ' "' + this.id + '" {\n';
      if(this.isStrict){
        dotScript = 'strict '+dotScript;
      }
    } else {
      dotScript = 'subgraph "' + this.id + '" {\n';
    }
    if (this.graphAttributs.length() > 0) {
      dotScript += '  graph' + this.graphAttributs.to_dot() + ';\n';
    }
    if (this.nodesAttributs.length() > 0) {
      dotScript += '  node' + this.nodesAttributs.to_dot() + ';\n';
    }
    if (this.edgesAttributs.length() > 0) {
      dotScript += '  edge' + this.edgesAttributs.to_dot() + ';\n';
    }
    for (keys = this.clusters.items.values();;) {
      entry = keys.next();
      if (entry.done) break;
      dotScript += entry.value.to_dot() + '\n';
    }
    for (keys = this.nodes.items.values();;) {
      entry = keys.next();
      if (entry.done) break;
      dotScript += '  ' + entry.value.to_dot() + ';\n';
    }
    for (i = 0, l = this.edges.length; i < l; ++i) {
      dotScript += '  ' + this.edges[i].to_dot() + ';\n';
    }
    dotScript += '}\n';
    return dotScript;
  };

  var Graph = graph$1.Graph;
  var graph = graphviz.graph = function(id) {
    var graph = new Graph(null, id);
    graph.type = 'graph';
    return graph;
  };
  var digraph = graphviz.digraph = function(id, isStrict) {
    var graph = new Graph(null, id);
    graph.type = 'digraph';
    graph.isStrict = isStrict || false;
    return graph;
  };

  exports.default = graphviz;
  exports.digraph = digraph;
  exports.graph = graph;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.js.map
